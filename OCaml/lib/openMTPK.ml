(* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.1.0
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ---------------------------------------------------------------------------- *)

open Swig
type c_enum_type = [ 
  `unknown
]
type c_enum_value = [ 
  `Int of int
]

type c_obj = c_enum_value c_obj_t
let module_name = "openMTPK"

exception BadArgs of string
exception BadMethodName of c_obj * string * string
exception NotObject of c_obj
exception NotEnumType of c_obj
exception LabelNotFromThisEnum of c_obj
exception InvalidDirectorCall of c_obj


  
  let array_to_vector v argcons array = 
    for i = 0 to (Array.length array) - 1 do
	ignore ((invoke v) "set" (C_list [ C_int i ; (argcons array.(i)) ]))
    done ;
    v
    
  let vector_to_array v argcons array =
    for i = 0; to (get_int ((invoke v) "size" C_void)) - 1 do
	array.(i) <- argcons ((invoke v) "[]" (C_int i))
    done ; 
    v
      

external _Basics_greatest_power_f : c_obj list -> c_obj list = "_wrap_Basics_greatest_poweropenMTPK" ;;
let _Basics_greatest_power arg = match _Basics_greatest_power_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Basics_rm_gcd_f : c_obj list -> c_obj list = "_wrap_Basics_rm_gcdopenMTPK" ;;
let _Basics_rm_gcd arg = match _Basics_rm_gcd_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_Basics_f : c_obj list -> c_obj list = "_wrap_new_BasicsopenMTPK" ;;
let _new_Basics arg = match _new_Basics_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_Basics_f : c_obj list -> c_obj list = "_wrap_delete_BasicsopenMTPK" ;;
let _delete_Basics arg = match _delete_Basics_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Primality_is_prime_f : c_obj list -> c_obj list = "_wrap_Primality_is_primeopenMTPK" ;;
let _Primality_is_prime arg = match _Primality_is_prime_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Primality_compute_miller_rabin_f : c_obj list -> c_obj list = "_wrap_Primality_compute_miller_rabinopenMTPK" ;;
let _Primality_compute_miller_rabin arg = match _Primality_compute_miller_rabin_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Primality_miller_rabin_prime_f : c_obj list -> c_obj list = "_wrap_Primality_miller_rabin_primeopenMTPK" ;;
let _Primality_miller_rabin_prime arg = match _Primality_miller_rabin_prime_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Primality_miller_rabin_f : c_obj list -> c_obj list = "_wrap_Primality_miller_rabinopenMTPK" ;;
let _Primality_miller_rabin arg = match _Primality_miller_rabin_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Primality_jacobian_number_f : c_obj list -> c_obj list = "_wrap_Primality_jacobian_numberopenMTPK" ;;
let _Primality_jacobian_number arg = match _Primality_jacobian_number_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Primality_solovoy_strassen_f : c_obj list -> c_obj list = "_wrap_Primality_solovoy_strassenopenMTPK" ;;
let _Primality_solovoy_strassen arg = match _Primality_solovoy_strassen_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Primality_mod_pow_f : c_obj list -> c_obj list = "_wrap_Primality_mod_powopenMTPK" ;;
let _Primality_mod_pow arg = match _Primality_mod_pow_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Primality_carmichael_num_f : c_obj list -> c_obj list = "_wrap_Primality_carmichael_numopenMTPK" ;;
let _Primality_carmichael_num arg = match _Primality_carmichael_num_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Primality_sieve_of_eratosthenes_f : c_obj list -> c_obj list = "_wrap_Primality_sieve_of_eratosthenesopenMTPK" ;;
let _Primality_sieve_of_eratosthenes arg = match _Primality_sieve_of_eratosthenes_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Primality_pollard_rho_f : c_obj list -> c_obj list = "_wrap_Primality_pollard_rhoopenMTPK" ;;
let _Primality_pollard_rho arg = match _Primality_pollard_rho_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Primality_ETF_f : c_obj list -> c_obj list = "_wrap_Primality_ETFopenMTPK" ;;
let _Primality_ETF arg = match _Primality_ETF_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_Primality_f : c_obj list -> c_obj list = "_wrap_new_PrimalityopenMTPK" ;;
let _new_Primality arg = match _new_Primality_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_Primality_f : c_obj list -> c_obj list = "_wrap_delete_PrimalityopenMTPK" ;;
let _delete_Primality arg = match _delete_Primality_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _BITS : c_obj -> Swig.c_obj = "_wrap_BITS" 
external _BYTE_LIMIT : c_obj -> Swig.c_obj = "_wrap_BYTE_LIMIT" 
external _RC4_byte_swap_f : c_obj list -> c_obj list = "_wrap_RC4_byte_swapopenMTPK" ;;
let _RC4_byte_swap arg = match _RC4_byte_swap_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RC4_trad_swap_f : c_obj list -> c_obj list = "_wrap_RC4_trad_swapopenMTPK" ;;
let _RC4_trad_swap arg = match _RC4_trad_swap_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RC4_XOR_swap_f : c_obj list -> c_obj list = "_wrap_RC4_XOR_swapopenMTPK" ;;
let _RC4_XOR_swap arg = match _RC4_XOR_swap_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RC4_KSA_f : c_obj list -> c_obj list = "_wrap_RC4_KSAopenMTPK" ;;
let _RC4_KSA arg = match _RC4_KSA_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RC4_PRGA_f : c_obj list -> c_obj list = "_wrap_RC4_PRGAopenMTPK" ;;
let _RC4_PRGA arg = match _RC4_PRGA_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RC4_store_hash_f : c_obj list -> c_obj list = "_wrap_RC4_store_hashopenMTPK" ;;
let _RC4_store_hash arg = match _RC4_store_hash_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RC4_compute_f : c_obj list -> c_obj list = "_wrap_RC4_computeopenMTPK" ;;
let _RC4_compute arg = match _RC4_compute_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_RC4_f : c_obj list -> c_obj list = "_wrap_new_RC4openMTPK" ;;
let _new_RC4 arg = match _new_RC4_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_RC4_f : c_obj list -> c_obj list = "_wrap_delete_RC4openMTPK" ;;
let _delete_RC4 arg = match _delete_RC4_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Cipher_C_cipher_f : c_obj list -> c_obj list = "_wrap_Cipher_C_cipheropenMTPK" ;;
let _Cipher_C_cipher arg = match _Cipher_C_cipher_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Cipher_KC_encode_f : c_obj list -> c_obj list = "_wrap_Cipher_KC_encodeopenMTPK" ;;
let _Cipher_KC_encode arg = match _Cipher_KC_encode_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Cipher_KC_cipher_f : c_obj list -> c_obj list = "_wrap_Cipher_KC_cipheropenMTPK" ;;
let _Cipher_KC_cipher arg = match _Cipher_KC_cipher_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_Cipher_f : c_obj list -> c_obj list = "_wrap_new_CipheropenMTPK" ;;
let _new_Cipher arg = match _new_Cipher_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_Cipher_f : c_obj list -> c_obj list = "_wrap_delete_CipheropenMTPK" ;;
let _delete_Cipher arg = match _delete_Cipher_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external f_init : unit -> unit = "f_openMTPK_init" ;;
let _ = f_init ()
let enum_to_int x (v : c_obj) =
   match v with
     C_enum _y ->
     (let y = _y in match (x : c_enum_type) with
       `unknown ->          (match y with
           `Int x -> (Swig.C_int x)
           | _ -> raise (LabelNotFromThisEnum v))
) | _ -> (C_int (get_int v))
let _ = Callback.register "openMTPK_enum_to_int" enum_to_int
let int_to_enum x y =
    match (x : c_enum_type) with
      `unknown -> C_enum (`Int y)
let _ = Callback.register "openMTPK_int_to_enum" int_to_enum

let create_Basics_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "greatest_power", _Basics_greatest_power ;
    "rm_gcd", _Basics_rm_gcd ;
    "~", _delete_Basics ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "Basics") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"Basics"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "Basics" create_Basics_from_ptr
let _ = Callback.register 
          "create_Basics_from_ptr"
          create_Basics_from_ptr



let create_Primality_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "is_prime", _Primality_is_prime ;
    "compute_miller_rabin", _Primality_compute_miller_rabin ;
    "miller_rabin_prime", _Primality_miller_rabin_prime ;
    "miller_rabin", _Primality_miller_rabin ;
    "jacobian_number", _Primality_jacobian_number ;
    "solovoy_strassen", _Primality_solovoy_strassen ;
    "mod_pow", _Primality_mod_pow ;
    "carmichael_num", _Primality_carmichael_num ;
    "sieve_of_eratosthenes", _Primality_sieve_of_eratosthenes ;
    "pollard_rho", _Primality_pollard_rho ;
    "ETF", _Primality_ETF ;
    "~", _delete_Primality ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "Primality") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"Primality"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "Primality" create_Primality_from_ptr
let _ = Callback.register 
          "create_Primality_from_ptr"
          create_Primality_from_ptr



let create_RC4_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "byte_swap", _RC4_byte_swap ;
    "trad_swap", _RC4_trad_swap ;
    "XOR_swap", _RC4_XOR_swap ;
    "KSA", _RC4_KSA ;
    "PRGA", _RC4_PRGA ;
    "store_hash", _RC4_store_hash ;
    "compute", _RC4_compute ;
    "~", _delete_RC4 ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "RC4") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"RC4"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "RC4" create_RC4_from_ptr
let _ = Callback.register 
          "create_RC4_from_ptr"
          create_RC4_from_ptr



let create_Cipher_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "C_cipher", _Cipher_C_cipher ;
    "KC_encode", _Cipher_KC_encode ;
    "KC_cipher", _Cipher_KC_cipher ;
    "~", _delete_Cipher ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "Cipher") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"Cipher"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "Cipher" create_Cipher_from_ptr
let _ = Callback.register 
          "create_Cipher_from_ptr"
          create_Cipher_from_ptr


let new_Basics clst = _new_Basics clst
let new_Primality clst = _new_Primality clst
let new_RC4 clst = _new_RC4 clst
let new_Cipher clst = _new_Cipher clst

  let rec swig_val t v = 
    match v with
        C_enum e -> enum_to_int t v
      | C_list l -> Swig.C_list (List.map (swig_val t) l)
      | C_array a -> Swig.C_array (Array.map (swig_val t) a)
      | _ -> Obj.magic v

