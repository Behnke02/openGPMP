# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

##   Generated via the command line invocation:
##	 swig -c++ -r -o RM_pkg_wrap.cpp RM_pkg.i


#                         srun.swg                            #
#
# This is the basic code that is needed at run time within R to
# provide and define the relevant classes.  It is included
# automatically in the generated code by copying the contents of
# srun.swg into the newly created binding code.


# This could be provided as a separate run-time library but this
# approach allows the code to be included directly into the
# generated bindings and so removes the need to have and install an
# additional library.  We may however end up with multiple copies of
# this and some confusion at run-time as to which class to use. This
# is an issue when we use NAMESPACES as we may need to export certain
# classes.

######################################################################

if(length(getClassDef("RSWIGStruct")) == 0) 
  setClass("RSWIGStruct", representation("VIRTUAL"))



if(length(getClassDef("ExternalReference")) == 0) 
# Should be virtual but this means it loses its slots currently
#representation("VIRTUAL")
  setClass("ExternalReference", representation( ref = "externalptr"))



if(length(getClassDef("NativeRoutinePointer")) == 0) 
  setClass("NativeRoutinePointer", 
              representation(parameterTypes = "character",
                             returnType = "character",
                             "VIRTUAL"), 
              contains = "ExternalReference")

if(length(getClassDef("CRoutinePointer")) == 0) 
  setClass("CRoutinePointer", contains = "NativeRoutinePointer")


if(length(getClassDef("EnumerationValue")) == 0) 
  setClass("EnumerationValue", contains = "integer")


if(!isGeneric("copyToR")) 
 setGeneric("copyToR",
            function(value, obj = new(gsub("Ref$", "", class(value)))) 
               standardGeneric("copyToR"
           ))

setGeneric("delete", function(obj) standardGeneric("delete"))


SWIG_createNewRef = 
function(className, ..., append = TRUE)
{
  f = get(paste("new", className, sep = "_"), mode = "function")

  f(...)
}

if(!isGeneric("copyToC")) 
 setGeneric("copyToC", 
             function(value, obj = SWIG_createNewRef(class(value)))
              standardGeneric("copyToC"
            ))


# 
defineEnumeration =
function(name, .values, where = topenv(parent.frame()), suffix = "Value")
{
   # Mirror the class definitions via the E analogous to .__C__
  defName = paste(".__E__", name, sep = "")
  delayedAssign(defName,  .values, assign.env = where)

  if(nchar(suffix))
    name = paste(name, suffix, sep = "")

  setClass(name, contains = "EnumerationValue", where = where)
}

enumToInteger <- function(name,type)
{
   if (is.character(name)) {
   ans <- as.integer(get(paste(".__E__", type, sep = ""))[name])
   if (is.na(ans)) {warning("enum not found ", name, " ", type)}
   ans
   } 
}

enumFromInteger =
function(i,type)
{
  itemlist <- get(paste(".__E__", type, sep=""))
  names(itemlist)[match(i, itemlist)]
}

coerceIfNotSubclass =
function(obj, type) 
{
    if(!is(obj, type)) {as(obj, type)} else obj
}


setClass("SWIGArray", representation(dims = "integer"), contains = "ExternalReference")

setMethod("length", "SWIGArray", function(x) x@dims[1])


defineEnumeration("SCopyReferences",
                   .values = c( "FALSE" = 0, "TRUE" = 1, "DEEP" = 2))

assert = 
function(condition, message = "")
{
  if(!condition)
    stop(message)

  TRUE
}


if(FALSE) {
print.SWIGFunction =
function(x, ...)
 {
 }
}


#######################################################################

R_SWIG_getCallbackFunctionStack =
function()
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_debug_getCallbackFunctionData")
}

R_SWIG_addCallbackFunctionStack =
function(fun, userData = NULL)
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_R_pushCallbackFunctionData", fun, userData)
}


#######################################################################



setClass('C++Reference', contains = 'ExternalReference')
setClass('_p_Basics', contains = 'C++Reference')
setClass('_p_Primality', contains = 'C++Reference')
setClass('_p_RC4', contains = 'C++Reference')
setClass('_p_Cipher', contains = 'C++Reference')



setMethod('[', "ExternalReference",
function(x,i,j, ..., drop=TRUE) 
if (!is.null(x$"__getitem__")) 
sapply(i, function(n) x$"__getitem__"(i=as.integer(n-1))))

setMethod('[<-' , "ExternalReference",
function(x,i,j, ..., value) 
if (!is.null(x$"__setitem__")) {
sapply(1:length(i), function(n) 
x$"__setitem__"(i=as.integer(i[n]-1), x=value[n]))
x
})

setAs('ExternalReference', 'character',
function(from) {if (!is.null(from$"__str__")) from$"__str__"()})

suppressMessages(suppressWarnings(setMethod('print', 'ExternalReference',
function(x) {print(as(x, "character"))})))

# Start of Basics_greatest_power

`Basics_greatest_power` = function(self, n, p, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  p = as.integer(p);
  
  if(length(p) > 1) {
    warning("using only the first element of p");
  };
  
  ;.Call('R_swig_Basics_greatest_power', self, n, p, as.logical(.copy), PACKAGE='RM_pkg');
  
}

attr(`Basics_greatest_power`, 'returnType') = 'integer'
attr(`Basics_greatest_power`, "inputTypes") = c('_p_Basics', 'integer', 'integer')
class(`Basics_greatest_power`) = c("SWIGFunction", class('Basics_greatest_power'))

# Start of Basics_rm_gcd

`Basics_rm_gcd` = function(self, x, y, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  x = as.integer(x);
  
  if(length(x) > 1) {
    warning("using only the first element of x");
  };
  
  y = as.integer(y);
  
  if(length(y) > 1) {
    warning("using only the first element of y");
  };
  
  ;.Call('R_swig_Basics_rm_gcd', self, x, y, as.logical(.copy), PACKAGE='RM_pkg');
  
}

attr(`Basics_rm_gcd`, 'returnType') = 'integer'
attr(`Basics_rm_gcd`, "inputTypes") = c('_p_Basics', 'integer', 'integer')
class(`Basics_rm_gcd`) = c("SWIGFunction", class('Basics_rm_gcd'))

# Start of new_Basics

`Basics` = function()
{
  ;ans = .Call('R_swig_new_Basics', PACKAGE='RM_pkg');
  ans <- if (is.null(ans)) ans
  else new("_p_Basics", ref=ans);
  
  reg.finalizer(ans@ref, delete_Basics);
  ans
  
}

attr(`Basics`, 'returnType') = '_p_Basics'
class(`Basics`) = c("SWIGFunction", class('Basics'))

# Start of delete_Basics

`delete_Basics` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_Basics', self, PACKAGE='RM_pkg');
  
}

attr(`delete_Basics`, 'returnType') = 'void'
attr(`delete_Basics`, "inputTypes") = c('_p_Basics')
class(`delete_Basics`) = c("SWIGFunction", class('delete_Basics'))

# Start of accessor method for Basics
setMethod('$', '_p_Basics', function(x, name)

{
  accessorFuns = list('greatest_power' = Basics_greatest_power, 'rm_gcd' = Basics_rm_gcd);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for Basics
setMethod('delete', '_p_Basics', function(obj) {delete_Basics(obj)})
# Start of Primality_is_prime

`Primality_is_prime` = function(self, n, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_Primality_is_prime', self, n, as.logical(.copy), PACKAGE='RM_pkg');
  
}

attr(`Primality_is_prime`, 'returnType') = 'logical'
attr(`Primality_is_prime`, "inputTypes") = c('_p_Primality', 'integer')
class(`Primality_is_prime`) = c("SWIGFunction", class('Primality_is_prime'))

# Start of Primality_compute_miller_rabin

`Primality_compute_miller_rabin` = function(self, d, n, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  d = as.integer(d);
  
  if(length(d) > 1) {
    warning("using only the first element of d");
  };
  
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_Primality_compute_miller_rabin', self, d, n, as.logical(.copy), PACKAGE='RM_pkg');
  
}

attr(`Primality_compute_miller_rabin`, 'returnType') = 'logical'
attr(`Primality_compute_miller_rabin`, "inputTypes") = c('_p_Primality', 'integer', 'integer')
class(`Primality_compute_miller_rabin`) = c("SWIGFunction", class('Primality_compute_miller_rabin'))

# Start of Primality_miller_rabin_prime

`Primality_miller_rabin_prime` = function(self, n, iters, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  iters = as.integer(iters);
  
  if(length(iters) > 1) {
    warning("using only the first element of iters");
  };
  
  ;.Call('R_swig_Primality_miller_rabin_prime', self, n, iters, as.logical(.copy), PACKAGE='RM_pkg');
  
}

attr(`Primality_miller_rabin_prime`, 'returnType') = 'logical'
attr(`Primality_miller_rabin_prime`, "inputTypes") = c('_p_Primality', 'integer', 'integer')
class(`Primality_miller_rabin_prime`) = c("SWIGFunction", class('Primality_miller_rabin_prime'))

# Start of Primality_miller_rabin

`Primality_miller_rabin` = function(self, inters, min_val, max_val)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  inters = as.integer(inters);
  
  if(length(inters) > 1) {
    warning("using only the first element of inters");
  };
  
  min_val = as.integer(min_val);
  
  if(length(min_val) > 1) {
    warning("using only the first element of min_val");
  };
  
  max_val = as.integer(max_val);
  
  if(length(max_val) > 1) {
    warning("using only the first element of max_val");
  };
  
  ;.Call('R_swig_Primality_miller_rabin', self, inters, min_val, max_val, PACKAGE='RM_pkg');
  
}

attr(`Primality_miller_rabin`, 'returnType') = 'void'
attr(`Primality_miller_rabin`, "inputTypes") = c('_p_Primality', 'integer', 'integer', 'integer')
class(`Primality_miller_rabin`) = c("SWIGFunction", class('Primality_miller_rabin'))

# Start of Primality_jacobian_number

`Primality_jacobian_number` = function(self, a, n, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  a = as.integer(a);
  
  if(length(a) > 1) {
    warning("using only the first element of a");
  };
  
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_Primality_jacobian_number', self, a, n, as.logical(.copy), PACKAGE='RM_pkg');
  
}

attr(`Primality_jacobian_number`, 'returnType') = 'integer'
attr(`Primality_jacobian_number`, "inputTypes") = c('_p_Primality', 'integer', 'integer')
class(`Primality_jacobian_number`) = c("SWIGFunction", class('Primality_jacobian_number'))

# Start of Primality_solovoy_strassen

`Primality_solovoy_strassen` = function(self, p, iters, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  p = as.integer(p);
  
  if(length(p) > 1) {
    warning("using only the first element of p");
  };
  
  iters = as.integer(iters);
  
  if(length(iters) > 1) {
    warning("using only the first element of iters");
  };
  
  ;.Call('R_swig_Primality_solovoy_strassen', self, p, iters, as.logical(.copy), PACKAGE='RM_pkg');
  
}

attr(`Primality_solovoy_strassen`, 'returnType') = 'logical'
attr(`Primality_solovoy_strassen`, "inputTypes") = c('_p_Primality', 'integer', 'integer')
class(`Primality_solovoy_strassen`) = c("SWIGFunction", class('Primality_solovoy_strassen'))

# Start of Primality_mod_pow

`Primality_mod_pow` = function(self, base, exponent, mod, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  base = as.integer(base);
  
  if(length(base) > 1) {
    warning("using only the first element of base");
  };
  
  exponent = as.integer(exponent);
  
  if(length(exponent) > 1) {
    warning("using only the first element of exponent");
  };
  
  mod = as.integer(mod);
  
  if(length(mod) > 1) {
    warning("using only the first element of mod");
  };
  
  ;.Call('R_swig_Primality_mod_pow', self, base, exponent, mod, as.logical(.copy), PACKAGE='RM_pkg');
  
}

attr(`Primality_mod_pow`, 'returnType') = 'integer'
attr(`Primality_mod_pow`, "inputTypes") = c('_p_Primality', 'integer', 'integer', 'integer')
class(`Primality_mod_pow`) = c("SWIGFunction", class('Primality_mod_pow'))

# Start of Primality_carmichael_num

`Primality_carmichael_num` = function(self, n, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_Primality_carmichael_num', self, n, as.logical(.copy), PACKAGE='RM_pkg');
  
}

attr(`Primality_carmichael_num`, 'returnType') = 'logical'
attr(`Primality_carmichael_num`, "inputTypes") = c('_p_Primality', 'integer')
class(`Primality_carmichael_num`) = c("SWIGFunction", class('Primality_carmichael_num'))

# Start of Primality_sieve_of_eratosthenes

`Primality_sieve_of_eratosthenes` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_Primality_sieve_of_eratosthenes', self, n, PACKAGE='RM_pkg');
  
}

attr(`Primality_sieve_of_eratosthenes`, 'returnType') = 'void'
attr(`Primality_sieve_of_eratosthenes`, "inputTypes") = c('_p_Primality', 'integer')
class(`Primality_sieve_of_eratosthenes`) = c("SWIGFunction", class('Primality_sieve_of_eratosthenes'))

# Start of Primality_pollard_rho

`Primality_pollard_rho` = function(self, n, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_Primality_pollard_rho', self, n, as.logical(.copy), PACKAGE='RM_pkg');
  
}

attr(`Primality_pollard_rho`, 'returnType') = 'integer'
attr(`Primality_pollard_rho`, "inputTypes") = c('_p_Primality', 'integer')
class(`Primality_pollard_rho`) = c("SWIGFunction", class('Primality_pollard_rho'))

# Start of Primality_ETF

`Primality_ETF` = function(self, n, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_Primality_ETF', self, n, as.logical(.copy), PACKAGE='RM_pkg');
  
}

attr(`Primality_ETF`, 'returnType') = 'integer'
attr(`Primality_ETF`, "inputTypes") = c('_p_Primality', 'integer')
class(`Primality_ETF`) = c("SWIGFunction", class('Primality_ETF'))

# Start of new_Primality

`Primality` = function()
{
  ;ans = .Call('R_swig_new_Primality', PACKAGE='RM_pkg');
  ans <- if (is.null(ans)) ans
  else new("_p_Primality", ref=ans);
  
  reg.finalizer(ans@ref, delete_Primality);
  ans
  
}

attr(`Primality`, 'returnType') = '_p_Primality'
class(`Primality`) = c("SWIGFunction", class('Primality'))

# Start of delete_Primality

`delete_Primality` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_Primality', self, PACKAGE='RM_pkg');
  
}

attr(`delete_Primality`, 'returnType') = 'void'
attr(`delete_Primality`, "inputTypes") = c('_p_Primality')
class(`delete_Primality`) = c("SWIGFunction", class('delete_Primality'))

# Start of accessor method for Primality
setMethod('$', '_p_Primality', function(x, name)

{
  accessorFuns = list('is_prime' = Primality_is_prime, 'compute_miller_rabin' = Primality_compute_miller_rabin, 'miller_rabin_prime' = Primality_miller_rabin_prime, 'miller_rabin' = Primality_miller_rabin, 'jacobian_number' = Primality_jacobian_number, 'solovoy_strassen' = Primality_solovoy_strassen, 'mod_pow' = Primality_mod_pow, 'carmichael_num' = Primality_carmichael_num, 'sieve_of_eratosthenes' = Primality_sieve_of_eratosthenes, 'pollard_rho' = Primality_pollard_rho, 'ETF' = Primality_ETF);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for Primality
setMethod('delete', '_p_Primality', function(obj) {delete_Primality(obj)})
# Start of RC4_byte_swap

`RC4_byte_swap` = function(self, a, b)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(a, "ExternalReference")) a = slot(a,"ref"); 
  if (inherits(b, "ExternalReference")) b = slot(b,"ref"); 
  ;.Call('R_swig_RC4_byte_swap', self, a, b, PACKAGE='RM_pkg');
  
}

attr(`RC4_byte_swap`, 'returnType') = 'void'
attr(`RC4_byte_swap`, "inputTypes") = c('_p_RC4', '_p_uint8_t', '_p_uint8_t')
class(`RC4_byte_swap`) = c("SWIGFunction", class('RC4_byte_swap'))

# Start of RC4_trad_swap

`RC4_trad_swap` = function(self, a, b)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  a = as.integer(a);
  b = as.integer(b);
  ;.Call('R_swig_RC4_trad_swap', self, a, b, PACKAGE='RM_pkg');
  
}

attr(`RC4_trad_swap`, 'returnType') = 'void'
attr(`RC4_trad_swap`, "inputTypes") = c('_p_RC4', 'integer', 'integer')
class(`RC4_trad_swap`) = c("SWIGFunction", class('RC4_trad_swap'))

# Start of RC4_XOR_swap

`RC4_XOR_swap` = function(self, a, b)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  a = as.integer(a);
  b = as.integer(b);
  ;.Call('R_swig_RC4_XOR_swap', self, a, b, PACKAGE='RM_pkg');
  
}

attr(`RC4_XOR_swap`, 'returnType') = 'void'
attr(`RC4_XOR_swap`, "inputTypes") = c('_p_RC4', 'integer', 'integer')
class(`RC4_XOR_swap`) = c("SWIGFunction", class('RC4_XOR_swap'))

# Start of RC4_KSA

`RC4_KSA` = function(self, key, S, swap_type)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  key = as(key, "character"); 
  S = as.integer(S);
  swap_type = as.integer(swap_type);
  
  if(length(swap_type) > 1) {
    warning("using only the first element of swap_type");
  };
  
  ;.Call('R_swig_RC4_KSA', self, key, S, swap_type, PACKAGE='RM_pkg');
  
}

attr(`RC4_KSA`, 'returnType') = 'void'
attr(`RC4_KSA`, "inputTypes") = c('_p_RC4', 'character', 'integer', 'integer')
class(`RC4_KSA`) = c("SWIGFunction", class('RC4_KSA'))

# Start of RC4_PRGA

`RC4_PRGA` = function(self, S, plaintext, ciphertext, swap_type)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  S = as.integer(S);
  plaintext = as(plaintext, "character"); 
  ciphertext = as.integer(ciphertext);
  swap_type = as.integer(swap_type);
  
  if(length(swap_type) > 1) {
    warning("using only the first element of swap_type");
  };
  
  ;.Call('R_swig_RC4_PRGA', self, S, plaintext, ciphertext, swap_type, PACKAGE='RM_pkg');
  
}

attr(`RC4_PRGA`, 'returnType') = 'void'
attr(`RC4_PRGA`, "inputTypes") = c('_p_RC4', 'integer', 'character', 'integer', 'integer')
class(`RC4_PRGA`) = c("SWIGFunction", class('RC4_PRGA'))

# Start of RC4_store_hash

`RC4_store_hash` = function(self, plaintext, hashtext, swap_type, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  plaintext = as(plaintext, "character"); 
  hashtext = as.integer(hashtext);
  swap_type = as.integer(swap_type);
  
  if(length(swap_type) > 1) {
    warning("using only the first element of swap_type");
  };
  
  ;.Call('R_swig_RC4_store_hash', self, plaintext, hashtext, swap_type, as.logical(.copy), PACKAGE='RM_pkg');
  
}

attr(`RC4_store_hash`, 'returnType') = 'character'
attr(`RC4_store_hash`, "inputTypes") = c('_p_RC4', 'character', 'integer', 'integer')
class(`RC4_store_hash`) = c("SWIGFunction", class('RC4_store_hash'))

# Start of RC4_compute

`RC4_compute` = function(self, key, plaintext, hashtext, swap_type)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  key = as(key, "character"); 
  plaintext = as(plaintext, "character"); 
  hashtext = as.integer(hashtext);
  swap_type = as.integer(swap_type);
  
  if(length(swap_type) > 1) {
    warning("using only the first element of swap_type");
  };
  
  ;ans = .Call('R_swig_RC4_compute', self, key, plaintext, hashtext, swap_type, PACKAGE='RM_pkg');
  ans <- if (is.null(ans)) ans
  else new("_p_unsigned_char", ref=ans);
  
  ans
  
}

attr(`RC4_compute`, 'returnType') = 'integer'
attr(`RC4_compute`, "inputTypes") = c('_p_RC4', 'character', 'character', 'integer', 'integer')
class(`RC4_compute`) = c("SWIGFunction", class('RC4_compute'))

# Start of new_RC4

`RC4` = function()
{
  ;ans = .Call('R_swig_new_RC4', PACKAGE='RM_pkg');
  ans <- if (is.null(ans)) ans
  else new("_p_RC4", ref=ans);
  
  reg.finalizer(ans@ref, delete_RC4);
  ans
  
}

attr(`RC4`, 'returnType') = '_p_RC4'
class(`RC4`) = c("SWIGFunction", class('RC4'))

# Start of delete_RC4

`delete_RC4` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_RC4', self, PACKAGE='RM_pkg');
  
}

attr(`delete_RC4`, 'returnType') = 'void'
attr(`delete_RC4`, "inputTypes") = c('_p_RC4')
class(`delete_RC4`) = c("SWIGFunction", class('delete_RC4'))

# Start of accessor method for RC4
setMethod('$', '_p_RC4', function(x, name)

{
  accessorFuns = list('byte_swap' = RC4_byte_swap, 'trad_swap' = RC4_trad_swap, 'XOR_swap' = RC4_XOR_swap, 'KSA' = RC4_KSA, 'PRGA' = RC4_PRGA, 'store_hash' = RC4_store_hash, 'compute' = RC4_compute);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for RC4
setMethod('delete', '_p_RC4', function(obj) {delete_RC4(obj)})
# Start of Cipher_C_cipher

`Cipher_C_cipher` = function(self, plaintext, key, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  plaintext = as(plaintext, "character"); 
  key = as.integer(key);
  
  if(length(key) > 1) {
    warning("using only the first element of key");
  };
  
  ;.Call('R_swig_Cipher_C_cipher', self, plaintext, key, as.logical(.copy), PACKAGE='RM_pkg');
  
}

attr(`Cipher_C_cipher`, 'returnType') = 'character'
attr(`Cipher_C_cipher`, "inputTypes") = c('_p_Cipher', 'character', 'integer')
class(`Cipher_C_cipher`) = c("SWIGFunction", class('Cipher_C_cipher'))

# Start of Cipher_KC_encode

`Cipher_KC_encode` = function(self, key, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  key = as(key, "character"); 
  ;.Call('R_swig_Cipher_KC_encode', self, key, as.logical(.copy), PACKAGE='RM_pkg');
  
}

attr(`Cipher_KC_encode`, 'returnType') = 'character'
attr(`Cipher_KC_encode`, "inputTypes") = c('_p_Cipher', 'character')
class(`Cipher_KC_encode`) = c("SWIGFunction", class('Cipher_KC_encode'))

# Start of Cipher_KC_cipher

`Cipher_KC_cipher` = function(self, plaintext, encoded_text, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  plaintext = as(plaintext, "character"); 
  encoded_text = as(encoded_text, "character"); 
  ;.Call('R_swig_Cipher_KC_cipher', self, plaintext, encoded_text, as.logical(.copy), PACKAGE='RM_pkg');
  
}

attr(`Cipher_KC_cipher`, 'returnType') = 'character'
attr(`Cipher_KC_cipher`, "inputTypes") = c('_p_Cipher', 'character', 'character')
class(`Cipher_KC_cipher`) = c("SWIGFunction", class('Cipher_KC_cipher'))

# Start of new_Cipher

`Cipher` = function()
{
  ;ans = .Call('R_swig_new_Cipher', PACKAGE='RM_pkg');
  ans <- if (is.null(ans)) ans
  else new("_p_Cipher", ref=ans);
  
  reg.finalizer(ans@ref, delete_Cipher);
  ans
  
}

attr(`Cipher`, 'returnType') = '_p_Cipher'
class(`Cipher`) = c("SWIGFunction", class('Cipher'))

# Start of delete_Cipher

`delete_Cipher` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_Cipher', self, PACKAGE='RM_pkg');
  
}

attr(`delete_Cipher`, 'returnType') = 'void'
attr(`delete_Cipher`, "inputTypes") = c('_p_Cipher')
class(`delete_Cipher`) = c("SWIGFunction", class('delete_Cipher'))

# Start of accessor method for Cipher
setMethod('$', '_p_Cipher', function(x, name)

{
  accessorFuns = list('C_cipher' = Cipher_C_cipher, 'KC_encode' = Cipher_KC_encode, 'KC_cipher' = Cipher_KC_cipher);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for Cipher
setMethod('delete', '_p_Cipher', function(obj) {delete_Cipher(obj)})


